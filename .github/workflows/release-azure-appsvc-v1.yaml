name: Reusable — Release Azure App Service
on:
  workflow_call:
    inputs:
      workspace_name:
        description: The name of the workspace to create the artifact for.
        type: string
        required: true
      resource_group_name:
        description: Web App resource group name.
        type: string
        required: true
      web_app_name:
        description: Web App name.
        type: string
        required: true
      environment:
        description: Environment where the artifact will be deployed.
        type: string
        required: true
      disable_auto_staging_deploy:
        description: Disable automatic deployments to the staging slot.
        type: boolean
        required: false
        default: false
      use_private_agent:
        description: Use a private agent to deploy the built artifact.
        type: boolean
        required: false
        default: true
      use_labels:
        description: Use labels to start the right environment's GitHub runner. If use_labels is true, also use_private_agent must be set to true
        type: boolean
        required: false
        default: false
      override_labels:
        description: Needed for special cases where the environment alone is not sufficient as a distinguishing label
        type: string
        required: false
        default: ""

permissions:
  contents: read
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ inputs.web_app_name }}-cd
  cancel-in-progress: true

env:
  BUNDLE_NAME: ${{ inputs.workspace_name }}
  RESOURCE_GROUP_NAME: ${{ inputs.resource_group_name }}
  WEB_APP_NAME: ${{ inputs.web_app_name }}
  ARM_USE_OIDC: true

jobs:
  build:
    name: Build
    runs-on: ubuntu-latest
    concurrency:
      group: ${{ format('{0}-build-{1}', github.run_id, inputs.workspace_name) }}
      cancel-in-progress: false
    permissions:
      id-token: write
    env:
      WORKSPACE_NAME: ${{ inputs.workspace_name }}

    steps:
      - name: Check if artifact already exists in this run
        id: check-artifact
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          echo "::debug::Checking for existing artifact named '${BUNDLE_NAME}' in current run ${GITHUB_RUN_ID}"
          names=$(gh api \
            -H "Accept: application/vnd.github+json" \
            /repos/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}/artifacts \
            -q '.artifacts[].name' || true)
          if echo "${names}" | grep -qx "${BUNDLE_NAME}"; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
            echo "### Artifact already exists ✅" >> "$GITHUB_STEP_SUMMARY"
            echo "Skipping build/upload in this invocation." >> "$GITHUB_STEP_SUMMARY"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Check out repository
        if: ${{ steps.check-artifact.outputs.exists != 'true' }}
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Build Package
        if: ${{ steps.check-artifact.outputs.exists != 'true' }}
        id: build-package
        uses: pagopa/dx/.github/actions/build-workspace@main
        with:
          workspace_name: ${{ env.WORKSPACE_NAME }}

      - name: Make artifact
        if: ${{ steps.check-artifact.outputs.exists != 'true' }}
        id: make-artifact
        env:
          PACKAGE_MANAGER: ${{ steps.build-package.outputs.package-manager }}
        working-directory: ${{ steps.build-package.outputs.workspace-path }}
        run: |
          set -euo pipefail

          # 1) Detect standalone + prepara struttura
          if grep -rq --include='next.config.*' -E "output:\s*['\"]standalone['\"]" .; then
            echo "::debug::Next.js standalone detected"
            # la cartella generata da Next
            STAND=".next/standalone"
            mkdir -p "$STAND"

            # 2) Trova l'entrypoint (server.js / server.mjs) e la sua dir
            ENTRY=$(find "$STAND" -maxdepth 5 -type f \( -name "server.js" -o -name "server.mjs" \) | head -n1 || true)
            if [ -z "$ENTRY" ]; then
              echo "::error::Entrypoint (server.js/mjs) non trovato dentro $STAND"
              exit 1
            fi
            ENTRY_DIR=$(dirname "$ENTRY")
            REL="${ENTRY#$STAND/}"                 # path relativo alla root del bundle
            echo "Entrypoint: $REL"
            echo "Entry dir : ${ENTRY_DIR#$STAND/}"

            # 3) Copia gli statici e la public NELLA CARTELLA dell'entrypoint
            if [ -d .next/static ]; then
              mkdir -p "$ENTRY_DIR/.next"
              rsync -av --delete .next/static/ "$ENTRY_DIR/.next/static/"
            else
              echo "::warning::.next/static non trovato"
            fi

            if [ -d public ]; then
              rsync -av --delete public/ "$ENTRY_DIR/public/"
            fi

            # 4) package.json che avvia quell'entry
            cat > "$STAND/package.json" <<EOF
          {
            "name": "smcr-standalone",
            "private": true,
            "scripts": {
              "start": "node \"$REL\""
            }
          }
          EOF

            # (debug)
            echo "TREE entry dir:"
            ls -la "$ENTRY_DIR" | sed 's/^/  /'
            echo "TREE entry .next:"
            ls -la "$ENTRY_DIR/.next" | sed 's/^/  /' || true

            # 5) Zippa dalla root di standalone
            (cd "$STAND" && zip -yr "$BUNDLE_NAME.zip" .)
            echo "artifact-path=$(realpath "$STAND/$BUNDLE_NAME.zip")" >> "$GITHUB_OUTPUT"
            exit 0
          fi


          if [ "$PACKAGE_MANAGER" = "pnpm" ]; then
            echo "::debug::The workspace uses pnpm"
            pnpm --filter "$WORKSPACE_NAME" deploy --prod bundle
            cd bundle && zip -yr "$BUNDLE_NAME.zip" .
            echo "artifact-path=$(realpath "$BUNDLE_NAME.zip")" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ "$PACKAGE_MANAGER" = "yarn" ]; then
            echo "::debug::The workspace uses yarn"
            yarn config set nodeLinker node-modules
            yarn config set nmHoistingLimits workspaces
            yarn workspaces focus --production
            zip -yr "$BUNDLE_NAME.zip" .
            echo "artifact-path=$(realpath "$BUNDLE_NAME.zip")" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "::error::Unsupported package manager: $PACKAGE_MANAGER"
          exit 1

      - name: Upload Artifact
        if: ${{ steps.check-artifact.outputs.exists != 'true' }}
        uses: pagopa/dx/.github/actions/upload-artifact@main
        with:
          file_path: ${{ steps.make-artifact.outputs.artifact-path }}
          bundle_name: ${{ env.BUNDLE_NAME }}

  validate:
    name: Validate Web App
    runs-on: ${{ inputs.use_labels && inputs.use_private_agent && (inputs.override_labels != '' && inputs.override_labels || inputs.environment) || inputs.use_private_agent && 'self-hosted' || 'ubuntu-latest' }}
    if: ${{ !github.event.act }}
    environment: ${{ inputs.environment }}-ci
    permissions:
      id-token: write
    outputs:
      use_staging_slot: ${{ steps.query-staging-slot.outputs.use_staging_slot }}

    steps:
      - name: Azure Login
        uses: pagopa/dx/.github/actions/azure-login@main
        env:
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}

      - name: Check for existing staging slot
        id: query-staging-slot
        run: |
          echo "::debug::Checking for existing deployment slots..."
          USE_STAGING_SLOT=$(az webapp deployment slot list \
            --resource-group "$RESOURCE_GROUP_NAME" \
            --name "$WEB_APP_NAME" \
            --query 'length([?name == `staging`]) > `0`')
          echo "use_staging_slot=$USE_STAGING_SLOT" >> "$GITHUB_OUTPUT"
          if [ "$USE_STAGING_SLOT" == "true" ]; then
            echo "### Staging slot found ✅" >> $GITHUB_STEP_SUMMARY
            echo "The deployment will proceed to the staging slot." >> $GITHUB_STEP_SUMMARY
          else
            echo "### No staging slot found" >> $GITHUB_STEP_SUMMARY
            echo "No staging slot is configured for this web app. The deployment will proceed to the production slot." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Check warm-up configuration (if slot present)
        if: ${{ steps.query-staging-slot.outputs.use_staging_slot == 'true' }}
        run: |
          IS_WARMUP_CONFIGURED=$(az webapp config appsettings list \
            --resource-group "$RESOURCE_GROUP_NAME" \
            --name "$WEB_APP_NAME" \
            --query 'length([?name==`WEBSITE_SWAP_WARMUP_PING_STATUSES`||name==`WEBSITE_SWAP_WARMUP_PING_PATH`]) == `2`')
          if [ "$IS_WARMUP_CONFIGURED" == "false" ]; then
            echo "::error::WEBSITE_SWAP_WARMUP_PING_PATH and WEBSITE_SWAP_WARMUP_PING_STATUSES are not set."
            echo "### Custom warm-up configuration needed ❌" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

  deploy:
    name: ${{ format('Deploy to {0}', needs.validate.outputs.use_staging_slot == 'true' && 'staging' || 'production') }}
    runs-on: ${{ inputs.use_labels && inputs.use_private_agent && (inputs.override_labels != '' && inputs.override_labels || inputs.environment) || inputs.use_private_agent && 'self-hosted' || 'ubuntu-latest' }}
    needs: [validate, build]
    if: ${{ !github.event.act }}
    environment: ${{ inputs.environment }}-cd
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Download Artifact
        uses: pagopa/dx/.github/actions/download-artifact@main
        with:
          bundle_name: ${{ env.BUNDLE_NAME }}

      - name: Determine artifact file path
        id: artifact-path
        run: |
          set -euo pipefail
          CANDIDATE="${BUNDLE_NAME}.zip"
          if [ -f "$CANDIDATE" ]; then
            echo "path=$CANDIDATE" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          found=$(find . -maxdepth 3 -type f -name "${BUNDLE_NAME}.zip" -o -name "*.zip" | head -n1 || true)
          if [ -z "$found" ]; then
            echo "::error::ZIP artifact not found"
            exit 1
          fi
          echo "path=$found" >> "$GITHUB_OUTPUT"

      - name: Azure Login
        uses: pagopa/dx/.github/actions/azure-login@main
        env:
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}

      - name: Deploy
        env:
          USE_STAGING_SLOT: ${{ needs.validate.outputs.use_staging_slot }}
          ZIP_PATH: ${{ steps.artifact-path.outputs.path }}
        run: |
          set -euo pipefail
          cmd=(
            "az" "webapp" "deploy"
            "--resource-group" "$RESOURCE_GROUP_NAME"
            "--name" "$WEB_APP_NAME"
            "--src-path" "$ZIP_PATH"
            "--type" "zip"
            "--async" "false"
          )
          if [[ "$USE_STAGING_SLOT" == "true" ]]; then
            echo "::debug::Deploying to staging slot"
            cmd+=("--slot" "staging")
          else
            echo "::debug::Deploying to production (no slot)"
          fi
          "${cmd[@]}"

  auto_approve_staging_deploy:
    name: Approve Staging Deployment
    runs-on: ubuntu-latest
    needs: [validate]
    continue-on-error: true
    if: ${{ !github.event.act && fromJSON(needs.validate.outputs.use_staging_slot) && !inputs.disable_auto_staging_deploy }}

    steps:
      - name: Approve deployment
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN_DEPLOYMENT_APPROVAL }}
          REQUIRED_ENVIRONMENT: ${{ inputs.environment }}-cd
        run: |
          if [ -z "$GH_TOKEN" ]; then
            echo "::error::GH_TOKEN_DEPLOYMENT_APPROVAL secret is not set."
            exit 1
          fi
          deployments=$(gh api -H "Accept: application/vnd.github+json" /repos/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID/pending_deployments)
          environment=$(echo "$deployments" | jq -r '.[].environment.name')
          if [ "$environment" != "$REQUIRED_ENVIRONMENT" ]; then
            echo "::error::Environment $REQUIRED_ENVIRONMENT not found."
            exit 1
          fi
          current_user_can_approve=$(echo "$deployments" | jq -r '.[].current_user_can_approve')
          if [ "$current_user_can_approve" != true ]; then
            GITHUB_USER=$(gh api user | jq -r '.login')
            echo "::error::$GITHUB_USER is not a reviewer"
            exit 1
          fi
          env_id=$(echo "$deployments" | jq -r '.[].environment.id')
          gh api --method POST \
            -H "Accept: application/vnd.github+json" \
            /repos/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID/pending_deployments \
            -F "environment_ids[]=$env_id" \
            -f "state=approved" \
            -f "comment=Approved automatically by the workflow."

  swap_staging_production:
    name: Swap slots
    runs-on: ${{ inputs.use_labels && inputs.use_private_agent && (inputs.override_labels != '' && inputs.override_labels || inputs.environment) || inputs.use_private_agent && 'self-hosted' || 'ubuntu-latest' }}
    needs: [validate, deploy]
    if: ${{ !github.event.act && fromJson(needs.validate.outputs.use_staging_slot) }}
    environment: ${{ inputs.environment }}-cd
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Azure Login
        uses: pagopa/dx/.github/actions/azure-login@main
        env:
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}

      - name: Swap Staging and Production Slots
        uses: pagopa/dx/actions/incremental-rollout@main
        with:
          resource_group_name: ${{ env.RESOURCE_GROUP_NAME }}
          resource_name: ${{ env.WEB_APP_NAME }}
          resource_type: "appsvc"
